<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1200, initial-scale=1" />
    <title>WCropper - 微信朋友圈发图工具</title>
    <style>
      :root {
        --bg: #ededed;
        --bg-strong: #ffffff;
        --fg: #1a1a1a;
        --muted: #888888;
        --line: #e5e5e5;
        --line-soft: #f0f0f0;
        --shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        --radius: 8px;
        --gap: 24px;
        --wechat-green: #07c160;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        color: var(--fg);
        font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "PingFang TC", "PingFang HK", "PingFang",
          "Noto Sans CJK SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
        background: var(--bg);
        min-height: 100vh;
        overflow: hidden;
      }

      button,
      input,
      select {
        font-family: inherit;
      }

      .page {
        width: 100%;
        margin: 0 auto;
        padding: 24px 80px 28px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        height: 100vh;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .title {
        font-size: clamp(22px, 3vw, 28px);
        font-weight: 500;
        letter-spacing: 0.05em;
      }

      .title-snap {
        font-size: 1em;
        letter-spacing: inherit;
        font-weight: inherit;
      }

      .header-actions {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .icon-link {
        width: 36px;
        height: 36px;
        border: 1px solid var(--line);
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: #fff;
        color: var(--fg);
        text-decoration: none;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .icon-link:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      }

      .icon-link svg {
        width: 16px;
        height: 16px;
        display: block;
        fill: currentColor;
      }

      .subtitle {
        font-size: 15px;
        line-height: 1.6;
        max-width: 760px;
        color: var(--muted);
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        color: var(--muted);
      }

      .workspace {
        display: grid;
        grid-template-columns: minmax(260px, 340px) minmax(0, 1fr) minmax(220px, 340px);
        gap: 18px;
        align-items: start;
      }

      .panel {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .card {
        position: relative;
        background: var(--bg-strong);
        border: none;
        border-radius: var(--radius);
        padding: 20px;
        box-shadow: var(--shadow);
      }

      .card-title {
        font-size: 14px;
        font-weight: 600;
        margin: 0 0 10px;
        text-transform: uppercase;
        letter-spacing: 0.18em;
      }

      .upload-area {
        border: 1px dashed var(--line);
        border-radius: 6px;
        padding: 24px 18px;
        display: grid;
        gap: 12px;
        text-align: center;
        background: #fafafa;
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      .upload-area.dragging {
        border-color: var(--wechat-green);
        background: rgba(7, 193, 96, 0.05);
      }

      .upload-area input {
        display: none;
      }

      .upload-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        border: none;
        padding: 10px 20px;
        background: var(--wechat-green);
        color: #fff;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: opacity 0.2s ease;
      }

      .btn:hover {
        opacity: 0.85;
      }

      .btn:active {
        opacity: 0.7;
      }

      .btn:disabled {
        background: var(--line);
        color: var(--muted);
        cursor: not-allowed;
        opacity: 0.5;
      }

      .btn.ghost {
        background: transparent;
        color: var(--wechat-green);
        border: 1px solid var(--wechat-green);
      }

      .btn.ghost:hover {
        background: rgba(7, 193, 96, 0.08);
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
      }

      .scheme-grid {
        display: grid;
        gap: 10px;
      }

      .scheme-card {
        display: grid;
        gap: 10px;
      }

      .scheme-card input {
        display: none;
      }

      .scheme-body {
        border: 1px solid var(--line-soft);
        border-radius: 6px;
        padding: 14px;
        display: grid;
        gap: 10px;
        background: #fff;
        cursor: pointer;
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      .scheme-card input:checked + .scheme-body {
        border-color: var(--wechat-green);
        background: rgba(7, 193, 96, 0.04);
      }

      .scheme-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 14px;
        font-weight: 600;
      }

      .scheme-tag {
        font-size: 12px;
        letter-spacing: 0.04em;
        text-transform: none;
        color: var(--muted);
      }

      .scheme-mini {
        display: grid;
        gap: 2px;
        width: 72px;
        height: 44px;
        border: 1px solid var(--line);
        border-radius: 8px;
        overflow: hidden;
      }

      .scheme-mini div {
        background: #e8e8e8;
      }

      .scheme-mini.quad {
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(2, 1fr);
      }

      .scheme-mini.duo {
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: 1fr;
      }

      .scheme-mini.vertical {
        grid-template-columns: 1fr;
        grid-template-rows: repeat(4, 1fr);
        width: 52px;
        height: 88px;
      }

      .controls {
        display: grid;
        gap: 10px;
      }

      .control-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-size: 12px;
      }

      .control-row input[type="range"] {
        flex: 1;
        accent-color: var(--wechat-green);
      }

      .control-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .control-actions button {
        border-radius: 6px;
        border: 1px solid var(--line);
        padding: 8px 14px;
        background: #fff;
        cursor: pointer;
        font-size: 13px;
        color: var(--fg);
        transition: all 0.2s ease;
      }

      .control-actions button:hover:not(:disabled) {
        border-color: var(--wechat-green);
        color: var(--wechat-green);
      }

      .control-actions button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .primary-action {
        width: 100%;
        border-radius: 6px;
        padding: 14px 16px;
        font-size: 15px;
        font-weight: 500;
        letter-spacing: 0.5px;
      }

      .primary-action:disabled {
        cursor: not-allowed;
        opacity: 0.4;
      }

      .stage-panel {
        display: grid;
        gap: 12px;
      }

      .results-panel {
        display: grid;
        gap: 12px;
      }

      .stage-wrap {
        background: var(--bg-strong);
        border: none;
        border-radius: var(--radius);
        padding: 16px;
        box-shadow: var(--shadow);
        display: grid;
        gap: 8px;
      }

      .stage {
        --stage-max-height: 52vh;
        --grid-gap: 6px;
        --stage-radius: 12px;
        position: relative;
        width: min(100%, calc(var(--stage-max-height) * var(--stage-ratio, 1)));
        aspect-ratio: var(--stage-ratio, 16 / 9);
        background: #fff;
        border-radius: var(--stage-radius);
        overflow: hidden;
        cursor: grab;
        margin: 0 auto;
      }

      .stage:active {
        cursor: grabbing;
      }

      .stage img {
        position: absolute;
        top: 0;
        left: 0;
        transform-origin: top left;
        user-select: none;
        pointer-events: none;
      }

      #source-image {
        opacity: 0;
        z-index: 0;
      }

      .tile-grid {
        position: absolute;
        inset: 0;
        display: grid;
        grid-template-columns: repeat(var(--cols, 1), 1fr);
        grid-template-rows: repeat(var(--rows, 1), 1fr);
        gap: var(--grid-gap);
        pointer-events: none;
        z-index: 1;
      }

      .tile-cell {
        position: relative;
        overflow: hidden;
        background: #fafafa;
        border: 1px solid var(--line);
      }

      .tile-image {
        width: auto;
        height: auto;
      }

      .stage-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 13px;
        color: var(--muted);
        background: repeating-linear-gradient(
          135deg,
          #fafafa 0px,
          #fafafa 10px,
          #f2f2f2 10px,
          #f2f2f2 20px
        );
        transition: opacity 0.2s ease;
        z-index: 2;
      }

      .stage[data-loaded="true"] .stage-placeholder {
        opacity: 0;
        pointer-events: none;
      }

      .results {
        display: grid;
        gap: 10px;
        background: var(--bg-strong);
        border: none;
        border-radius: var(--radius);
        padding: 20px;
        box-shadow: var(--shadow);
      }

      .results-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .results-title {
        margin: 0;
        font-size: 16px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .output-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        align-content: start;
        align-items: start;
        grid-auto-rows: max-content;
      }

      .output-grid.vertical-stack {
        grid-template-columns: repeat(3, minmax(100px, 1fr));
        justify-content: start;
      }

      .output-card {
        border: 1px solid var(--line);
        border-radius: 6px;
        padding: 10px;
        display: grid;
        gap: 8px;
        background: #fff;
        transition: box-shadow 0.2s ease;
      }

      .output-card:hover {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      .output-card img {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 4px;
        border: 1px solid var(--line);
        background: #fafafa;
      }

      .output-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
      }

      .output-meta a,
      .output-meta button {
        color: var(--wechat-green);
        text-decoration: none;
        border: 1px solid var(--line);
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 12px;
        background: #fff;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .output-meta a:hover,
      .output-meta button:hover {
        border-color: var(--wechat-green);
        background: rgba(7, 193, 96, 0.06);
      }

      .output-empty {
        min-height: 120px;
        border: 1px dashed var(--line-soft);
        border-radius: 12px;
        background: #fafafa;
      }

    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <div class="title">
          <svg style="width: 1.2em; height: 1.2em; vertical-align: -0.15em; display: inline-block;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
            <path d="M1023.162182 641.303273c0-143.243636-143.243636-260.910545-306.944-260.910546-168.820364 0-306.944 117.666909-306.944 260.910546s133.003636 260.910545 306.944 260.910545c35.816727 0 71.633455-10.24 107.426909-20.456727l97.210182 56.273454-25.576728-92.090181c71.633455-56.273455 127.883636-127.906909 127.883637-204.637091z m-404.130909-46.056728c-20.456727 0-35.816727-15.36-35.816728-35.816727 0-15.336727 20.456727-35.816727 35.816728-35.816727 25.576727 0 46.056727 15.36 46.056727 35.816727-0.023273 15.36-20.48 35.816727-46.056727 35.816727z m194.397091 0c-15.336727 0-35.816727-15.36-35.816728-35.816727 0-15.336727 20.456727-35.816727 35.816728-35.816727 25.576727 0 46.056727 15.36 46.056727 35.816727 0 15.36-15.36 35.816727-46.056727 35.816727z m0 0" fill="#07c160" />
            <path d="M358.097455 104.122182c-199.517091 0-358.120727 133.026909-358.120728 306.967273 0 97.210182 56.273455 179.060364 143.243637 240.453818L107.426909 758.970182l127.906909-61.393455c46.033455 10.24 81.850182 20.456727 127.906909 20.456728h35.816728c-5.12-25.576727-10.216727-51.153455-10.216728-76.730182 0-158.580364 133.003636-286.510545 306.944-286.510546h35.816728C690.641455 211.549091 537.157818 104.122182 358.097455 104.122182z m-112.54691 240.453818c-25.576727 0-56.273455-15.36-56.273454-46.056727 0-25.6 25.6-46.056727 56.273454-46.056728 25.576727 0 46.056727 15.36 46.056728 46.056728-5.12 30.696727-20.456727 46.056727-46.056728 46.056727z m250.693819 0c-25.576727 0-56.273455-15.36-56.273455-46.056727 0-25.6 25.576727-46.056727 56.273455-46.056728 25.576727 0 46.056727 15.36 46.056727 46.056728-0.023273 30.696727-20.48 46.056727-46.056727 46.056727z m0 0" fill="#07c160" />
          </svg>
          <span class="title-snap">Cropper</span>
        </div>
        <div class="header-actions">
          <a href="https://github.com/wildematt/wcropper" class="icon-link" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
            <svg viewBox="0 0 16 16" width="16" height="16" fill="currentColor">
              <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
            </svg>
          </a>
        </div>
      </header>

      <main class="workspace">
        <section class="panel">
          <div class="card" id="upload-card">
            <h2 class="card-title">上传</h2>
            <div class="upload-area" id="upload-area">
              <input id="file-input" type="file" accept="image/*" />
              <div class="upload-actions">
                <button class="btn" id="select-btn" type="button">上传图片</button>
                <button class="btn ghost" id="paste-btn" type="button">粘贴图片</button>
              </div>
            </div>
          </div>

          <div class="card" id="selection-card">
            <h2 class="card-title">选择</h2>
            <div class="scheme-grid">
              <label class="scheme-card">
                <input type="radio" name="scheme" value="quad" checked />
                <div class="scheme-body">
                  <div class="scheme-head">
                    <span>四宫格</span>
                    <span class="scheme-tag">朋友圈 2x2 完整显示</span>
                  </div>
                  <div class="scheme-mini quad">
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                  </div>
                </div>
              </label>

              <label class="scheme-card">
                <input type="radio" name="scheme" value="nine" />
                <div class="scheme-body">
                  <div class="scheme-head">
                    <span>九宫格</span>
                    <span class="scheme-tag">朋友圈 3x3 完整显示</span>
                  </div>
                  <div class="scheme-mini quad" style="grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);">
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                  </div>
                </div>
              </label>

              <label class="scheme-card">
                <input type="radio" name="scheme" value="duo" />
                <div class="scheme-body">
                  <div class="scheme-head">
                    <span>双图</span>
                    <span class="scheme-tag">朋友圈 1x2 并排显示</span>
                  </div>
                  <div class="scheme-mini duo">
                    <div></div>
                    <div></div>
                  </div>
                </div>
              </label>
            </div>
          </div>

          <div class="card" id="adjust-card">
            <h2 class="card-title">调整</h2>
            <div class="controls">
              <div class="control-row">
                <span>缩放</span>
                <input id="zoom-range" type="range" min="1" max="3" step="0.01" value="1" />
                <span id="zoom-value">1.00x</span>
              </div>
              <div class="control-actions">
                <button type="button" id="fit-btn">适配</button>
                <button type="button" id="center-btn">居中</button>
                <button type="button" id="rotate-btn" disabled>旋转</button>
                <button type="button" id="mirror-btn" disabled>镜像</button>
              </div>
            </div>
          </div>
        </section>

        <section class="stage-panel">
          <div class="stage-wrap">
            <div class="stage" id="stage" data-loaded="false">
              <div class="tile-grid" id="tile-grid"></div>
              <img id="source-image" alt="uploaded" />
              <div class="stage-placeholder">图片预览</div>
            </div>
          </div>
        </section>

        <section class="results-panel">
          <div class="card">
            <button class="btn primary-action" id="crop-btn" disabled>确认裁切</button>
          </div>
          <div class="results">
            <div class="results-header">
              <h2 class="results-title">结果</h2>
            </div>
            <div class="output-grid" id="output-grid">
              <div class="output-empty" aria-hidden="true"></div>
            </div>
          </div>
        </section>
      </main>
    </div>

    <script>
      const schemes = {
        quad: {
          id: "quad",
          name: "四宫格",
          cols: 2,
          rows: 2,
          cellW: 300,
          cellH: 300,
        },
        nine: {
          id: "nine",
          name: "九宫格",
          cols: 3,
          rows: 3,
          cellW: 300,
          cellH: 300,
        },
        duo: {
          id: "duo",
          name: "双图",
          cols: 2,
          rows: 1,
          cellW: 300,
          cellH: 300,
        },
      };

      const state = {
        scheme: schemes.quad,
        imageLoaded: false,
        originalImage: null,
        rotation: 0,
        mirror: false,
        imgWidth: 0,
        imgHeight: 0,
        scale: 1,
        minScale: 1,
        maxScale: 3,
        offsetX: 0,
        offsetY: 0,
        dragging: false,
        dragStartX: 0,
        dragStartY: 0,
        dragOriginX: 0,
        dragOriginY: 0,
      };

      const fileInput = document.getElementById("file-input");
      const uploadArea = document.getElementById("upload-area");
      const selectBtn = document.getElementById("select-btn");
      const pasteBtn = document.getElementById("paste-btn");
      const leftPanel = document.querySelector(".panel");
      const uploadCard = document.getElementById("upload-card");
      const selectionCard = document.getElementById("selection-card");
      const adjustCard = document.getElementById("adjust-card");
      const stage = document.getElementById("stage");
      const stageWrap = document.querySelector(".stage-wrap");
      const resultsCard = document.querySelector(".results");
      const resultsHeader = document.querySelector(".results-header");
      const sourceImage = document.getElementById("source-image");
      const zoomRange = document.getElementById("zoom-range");
      const zoomValue = document.getElementById("zoom-value");
      const fitBtn = document.getElementById("fit-btn");
      const centerBtn = document.getElementById("center-btn");
      const rotateBtn = document.getElementById("rotate-btn");
      const mirrorBtn = document.getElementById("mirror-btn");
      const cropBtn = document.getElementById("crop-btn");
      const tileGrid = document.getElementById("tile-grid");
      const outputGrid = document.getElementById("output-grid");

      const tiles = [];
      let verticalLayoutScheduled = false;
      let pendingFit = false;
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const getGridGap = () => {
        const value = getComputedStyle(stage).getPropertyValue("--grid-gap");
        const parsed = parseFloat(value);
        return Number.isFinite(parsed) ? parsed : 0;
      };
      const getContentMetrics = () => {
        const rect = stage.getBoundingClientRect();
        const gap = getGridGap();
        const { cols, rows } = state.scheme;
        const contentW = rect.width - gap * (cols - 1);
        const contentH = rect.height - gap * (rows - 1);
        const cellW = contentW / cols;
        const cellH = contentH / rows;
        return { rect, gap, cols, rows, contentW, contentH, cellW, cellH };
      };
      const mapStageToContent = (value, cell, gap, count) => {
        const segment = cell + gap;
        const maxStage = segment * count - gap;
        const clamped = clamp(value, 0, maxStage);
        const index = Math.min(count - 1, Math.floor(clamped / segment));
        const within = clamped - index * segment;
        return index * cell + Math.min(within, cell);
      };

      const getOutputCardHeightEstimate = (scheme = state.scheme, columnWidth = null) => {
        const gridStyles = getComputedStyle(outputGrid);
        const columns = gridStyles.gridTemplateColumns.split(" ");
        const gridWidth = outputGrid.getBoundingClientRect().width || 0;
        const resolvedColumnWidth =
          columnWidth ||
          parseFloat(columns[0]) ||
          (scheme.id === "nine" ? gridWidth / 3 : gridWidth / 2) ||
          160;
        const ratio = scheme.cellW / scheme.cellH;

        const tempCard = document.createElement("div");
        tempCard.className = "output-card";
        tempCard.style.position = "absolute";
        tempCard.style.visibility = "hidden";
        tempCard.style.pointerEvents = "none";
        tempCard.style.width = `${resolvedColumnWidth}px`;
        tempCard.style.left = "-9999px";
        tempCard.style.top = "0";

        const tempImg = document.createElement("img");
        tempImg.style.width = "100%";
        tempImg.style.height = "auto";
        tempImg.style.aspectRatio = `${ratio}`;
        tempImg.src =
          "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";

        const meta = document.createElement("div");
        meta.className = "output-meta";
        const btn1 = document.createElement("button");
        btn1.textContent = "下载";
        const btn2 = document.createElement("button");
        btn2.textContent = "复制";
        meta.appendChild(btn1);
        meta.appendChild(btn2);

        tempCard.appendChild(tempImg);
        tempCard.appendChild(meta);
        outputGrid.appendChild(tempCard);
        const height = tempCard.getBoundingClientRect().height || 0;
        tempCard.remove();
        return height;
      };

      const getVerticalBaseline = () => {
        const gridStyles = getComputedStyle(outputGrid);
        const rowGap = parseFloat(gridStyles.rowGap || gridStyles.gap) || 0;
        const resultsStyles = getComputedStyle(resultsCard);
        const resultsPadY =
          parseFloat(resultsStyles.paddingTop) + parseFloat(resultsStyles.paddingBottom);
        const headerHeight = resultsHeader.getBoundingClientRect().height;
        const gridWidth = outputGrid.getBoundingClientRect().width || 0;
        const columnWidth = Math.min(200, Math.max(160, gridWidth / 3 || 160));
        const cardHeight = getOutputCardHeightEstimate(schemes.nine, columnWidth);
        const stackHeight =
          cardHeight * schemes.nine.rows + rowGap * (schemes.nine.rows - 1);
        const resultsMinHeight = Math.max(
          headerHeight + resultsPadY + stackHeight,
          160
        );
        const resultsTop = resultsCard.getBoundingClientRect().top;
        const panelTop = leftPanel.getBoundingClientRect().top;
        const gap = parseFloat(getComputedStyle(leftPanel).gap) || 0;
        const uploadHeight = uploadCard.getBoundingClientRect().height;
        const adjustHeight = adjustCard.getBoundingClientRect().height;
        const resultsBottom = resultsTop + resultsMinHeight;
        const targetPanelHeight = Math.max(resultsBottom - panelTop, 0);
        const targetSelectionHeight = Math.max(
          targetPanelHeight - uploadHeight - adjustHeight - gap * 2,
          0
        );
        return {
          resultsMinHeight,
          resultsBottom,
          targetPanelHeight,
          targetSelectionHeight,
        };
      };

      const updateVerticalLayout = () => {
        stage.style.setProperty("--stage-max-height", "52vh");
        selectionCard.style.removeProperty("min-height");
        leftPanel.style.removeProperty("min-height");
        outputGrid.style.removeProperty("min-height");
        resultsCard.style.removeProperty("min-height");

        const baseline = getVerticalBaseline();
        resultsCard.style.minHeight = `${Math.round(baseline.resultsMinHeight)}px`;
        selectionCard.style.minHeight = `${Math.round(baseline.targetSelectionHeight)}px`;
        leftPanel.style.minHeight = `${Math.round(baseline.targetPanelHeight)}px`;

        if (state.scheme.id !== "nine") {
          return;
        }
        const stageWrapRect = stageWrap.getBoundingClientRect();
        const wrapStyles = getComputedStyle(stageWrap);
        const padY =
          parseFloat(wrapStyles.paddingTop) + parseFloat(wrapStyles.paddingBottom);
        const borderY =
          parseFloat(wrapStyles.borderTopWidth) +
          parseFloat(wrapStyles.borderBottomWidth);
        const maxHeight = Math.max(
          baseline.resultsBottom - stageWrapRect.top - padY - borderY,
          160
        );
        stage.style.setProperty("--stage-max-height", `${Math.round(maxHeight)}px`);
      };

      const scheduleVerticalLayout = (shouldFit = false) => {
        if (shouldFit) {
          pendingFit = true;
        }
        if (verticalLayoutScheduled) return;
        verticalLayoutScheduled = true;
        window.requestAnimationFrame(() => {
          verticalLayoutScheduled = false;
          updateVerticalLayout();
          if (pendingFit && state.imageLoaded) {
            pendingFit = false;
            fitImageToStage();
          }
        });
      };

      const setImageLoadedState = (loaded) => {
        state.imageLoaded = loaded;
        stage.dataset.loaded = loaded ? "true" : "false";
        cropBtn.disabled = !loaded;
        rotateBtn.disabled = !loaded;
        mirrorBtn.disabled = !loaded;
      };

      const renderTiles = () => {
        tileGrid.innerHTML = "";
        tiles.length = 0;
        const { cols, rows } = state.scheme;
        tileGrid.style.setProperty("--cols", cols.toString());
        tileGrid.style.setProperty("--rows", rows.toString());

        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < cols; col += 1) {
            const cell = document.createElement("div");
            cell.className = "tile-cell";
            if (row === 0 && col === 0) {
              cell.style.borderTopLeftRadius = "var(--stage-radius)";
            }
            if (row === 0 && col === cols - 1) {
              cell.style.borderTopRightRadius = "var(--stage-radius)";
            }
            if (row === rows - 1 && col === 0) {
              cell.style.borderBottomLeftRadius = "var(--stage-radius)";
            }
            if (row === rows - 1 && col === cols - 1) {
              cell.style.borderBottomRightRadius = "var(--stage-radius)";
            }
            const img = document.createElement("img");
            img.className = "tile-image";
            img.alt = "";
            img.draggable = false;
            cell.appendChild(img);
            tileGrid.appendChild(cell);
            tiles.push({ row, col, img });
          }
        }

        if (state.imageLoaded) {
          updateTileSources();
        }
        updateTileTransforms();
      };

      const setStageRatio = () => {
        const { cols, rows, cellW, cellH } = state.scheme;
        const ratio = (cellW / cellH) * (cols / rows);
        stage.style.setProperty("--stage-ratio", ratio.toString());
        stage.style.setProperty("--cols", cols.toString());
        stage.style.setProperty("--rows", rows.toString());
      };

      const updateTileSources = () => {
        const src = sourceImage.src;
        tiles.forEach((tile) => {
          tile.img.src = src;
        });
      };

      const updateTileTransforms = () => {
        if (!tiles.length) return;
        const { cellW, cellH } = getContentMetrics();

        tiles.forEach((tile) => {
          const tileX = tile.col * cellW;
          const tileY = tile.row * cellH;
          tile.img.style.transform = `translate(${state.offsetX - tileX}px, ${
            state.offsetY - tileY
          }px) scale(${state.scale})`;
        });
      };

      const updateZoomUI = () => {
        zoomRange.value = state.scale.toFixed(3);
        zoomValue.textContent = `${state.scale.toFixed(2)}x`;
      };

      const clampOffsets = () => {
        const { contentW, contentH } = getContentMetrics();
        const imgW = state.imgWidth * state.scale;
        const imgH = state.imgHeight * state.scale;
        const minX = contentW - imgW;
        const minY = contentH - imgH;
        state.offsetX = clamp(state.offsetX, minX, 0);
        state.offsetY = clamp(state.offsetY, minY, 0);
      };

      const applyTransform = () => {
        sourceImage.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px) scale(${state.scale})`;
        updateTileTransforms();
      };

      const fitImageToStage = () => {
        const { contentW, contentH } = getContentMetrics();
        state.minScale = Math.max(contentW / state.imgWidth, contentH / state.imgHeight);
        state.maxScale = state.minScale * 3.5;
        state.scale = state.minScale;
        state.offsetX = (contentW - state.imgWidth * state.scale) / 2;
        state.offsetY = (contentH - state.imgHeight * state.scale) / 2;
        clampOffsets();
        zoomRange.min = state.minScale.toFixed(3);
        zoomRange.max = state.maxScale.toFixed(3);
        zoomRange.step = Math.max(state.minScale / 200, 0.001).toFixed(3);
        updateZoomUI();
        applyTransform();
      };

      const centerImage = () => {
        const { contentW, contentH } = getContentMetrics();
        state.offsetX = (contentW - state.imgWidth * state.scale) / 2;
        state.offsetY = (contentH - state.imgHeight * state.scale) / 2;
        clampOffsets();
        applyTransform();
      };

      const zoomTo = (newScale, focusX, focusY) => {
        const { rect, gap, cols, rows, cellW, cellH, contentW, contentH } = getContentMetrics();
        const fx = focusX ?? rect.width / 2;
        const fy = focusY ?? rect.height / 2;
        const contentFx = mapStageToContent(fx, cellW, gap, cols);
        const contentFy = mapStageToContent(fy, cellH, gap, rows);
        const imageX = (contentFx - state.offsetX) / state.scale;
        const imageY = (contentFy - state.offsetY) / state.scale;
        state.scale = clamp(newScale, state.minScale, state.maxScale);
        state.offsetX = clamp(contentFx - imageX * state.scale, contentW - state.imgWidth * state.scale, 0);
        state.offsetY = clamp(contentFy - imageY * state.scale, contentH - state.imgHeight * state.scale, 0);
        clampOffsets();
        applyTransform();
        updateZoomUI();
      };

      const setOutputEmpty = () => {
        outputGrid.innerHTML = '<div class="output-empty" aria-hidden="true"></div>';
      };

      const updateOutputLayout = () => {
        outputGrid.classList.toggle("vertical-stack", state.scheme.id === "nine");
      };

      const updateMirrorLabel = () => {
        mirrorBtn.textContent = "镜像";
      };

      const setSourceImage = (src) => {
        sourceImage.onload = () => {
          state.imgWidth = sourceImage.naturalWidth;
          state.imgHeight = sourceImage.naturalHeight;
          setImageLoadedState(true);
          updateMirrorLabel();
          updateTileSources();
          scheduleVerticalLayout(true);
          setOutputEmpty();
        };
        sourceImage.src = src;
      };

      const applyRotation = () => {
        if (!state.originalImage) return;
        const angle = (state.rotation + 360) % 360;
        const radians = (angle * Math.PI) / 180;
        const swap = angle % 180 !== 0;
        const canvas = document.createElement("canvas");
        canvas.width = swap ? state.originalImage.height : state.originalImage.width;
        canvas.height = swap ? state.originalImage.width : state.originalImage.height;
        const ctx = canvas.getContext("2d");
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(radians);
        ctx.scale(state.mirror ? -1 : 1, 1);
        ctx.drawImage(
          state.originalImage,
          -state.originalImage.width / 2,
          -state.originalImage.height / 2
        );
        setSourceImage(canvas.toDataURL("image/png"));
      };

      const rotateBy = (delta) => {
        if (!state.originalImage) return;
        state.rotation = (state.rotation + delta + 360) % 360;
        applyRotation();
      };

      const copyImage = async (dataUrl, button) => {
        if (!navigator.clipboard || !window.ClipboardItem) {
          button.textContent = "不支持";
          setTimeout(() => {
            button.textContent = "复制";
          }, 1200);
          return;
        }

        try {
          const blob = await (await fetch(dataUrl)).blob();
          await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
          button.textContent = "已复制";
          setTimeout(() => {
            button.textContent = "复制";
          }, 1200);
        } catch (error) {
          button.textContent = "失败";
          setTimeout(() => {
            button.textContent = "复制";
          }, 1200);
        }
      };

      const drawSlices = () => {
        if (!state.imageLoaded) return;
        const { cols, rows, cellW, cellH } = getContentMetrics();
        const { name } = state.scheme;
        outputGrid.innerHTML = "";

        let index = 0;
        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < cols; col += 1) {
            index += 1;
            const sx = (col * cellW - state.offsetX) / state.scale;
            const sy = (row * cellH - state.offsetY) / state.scale;
            const sw = cellW / state.scale;
            const sh = cellH / state.scale;
            const canvas = document.createElement("canvas");
            canvas.width = Math.max(1, Math.round(sw));
            canvas.height = Math.max(1, Math.round(sh));
            const ctx = canvas.getContext("2d");
            ctx.drawImage(
              sourceImage,
              sx,
              sy,
              sw,
              sh,
              0,
              0,
              canvas.width,
              canvas.height
            );
            const dataUrl = canvas.toDataURL("image/png");

            const card = document.createElement("div");
            card.className = "output-card";
            const img = document.createElement("img");
            img.src = dataUrl;
            img.alt = `${name} 切片 ${index}`;
            img.style.aspectRatio = `${canvas.width} / ${canvas.height}`;
            const meta = document.createElement("div");
            meta.className = "output-meta";
            const link = document.createElement("a");
            link.href = dataUrl;
            link.download = `wechat-${state.scheme.id}-${index}.png`;
            link.textContent = "下载";
            const copyBtn = document.createElement("button");
            copyBtn.type = "button";
            copyBtn.textContent = "复制";
            copyBtn.addEventListener("click", () => {
              copyImage(dataUrl, copyBtn);
            });
            meta.appendChild(link);
            meta.appendChild(copyBtn);
            card.appendChild(img);
            card.appendChild(meta);
            outputGrid.appendChild(card);
          }
        }
      };

      const loadFile = (file) => {
        if (!file) return;
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          URL.revokeObjectURL(url);
          state.originalImage = img;
          state.rotation = 0;
          state.mirror = false;
          applyRotation();
        };
        img.src = url;
      };

      fileInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        loadFile(file);
      });

      selectBtn.addEventListener("click", () => {
        fileInput.click();
      });

      uploadArea.addEventListener("dragover", (event) => {
        event.preventDefault();
        uploadArea.classList.add("dragging");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("dragging");
      });

      uploadArea.addEventListener("drop", (event) => {
        event.preventDefault();
        uploadArea.classList.remove("dragging");
        const file = event.dataTransfer.files[0];
        loadFile(file);
      });

      document.addEventListener("paste", (event) => {
        const items = event.clipboardData?.items;
        if (!items) return;
        for (const item of items) {
          if (item.kind === "file" && item.type.startsWith("image/")) {
            const file = item.getAsFile();
            loadFile(file);
            break;
          }
        }
      });

      const updatePasteLabel = (text) => {
        pasteBtn.textContent = text;
        window.clearTimeout(pasteBtn._timer);
        pasteBtn._timer = window.setTimeout(() => {
          pasteBtn.textContent = "粘贴图片";
        }, 1200);
      };

      const pasteFromClipboard = async () => {
        if (!navigator.clipboard || !navigator.clipboard.read) {
          updatePasteLabel("不支持");
          return;
        }

        try {
          const items = await navigator.clipboard.read();
          for (const item of items) {
            const type = item.types.find((itemType) => itemType.startsWith("image/"));
            if (type) {
              const blob = await item.getType(type);
              const file = new File([blob], "clipboard.png", { type });
              loadFile(file);
              updatePasteLabel("已导入");
              return;
            }
          }
          updatePasteLabel("无图片");
        } catch (error) {
          updatePasteLabel("失败");
        }
      };

      pasteBtn.addEventListener("click", () => {
        pasteFromClipboard();
      });

      document.querySelectorAll('input[name="scheme"]').forEach((input) => {
        input.addEventListener("change", (event) => {
          const value = event.target.value;
          state.scheme = schemes[value];
          setStageRatio();
          renderTiles();
          updateOutputLayout();
          if (state.imageLoaded) {
            scheduleVerticalLayout(true);
            setOutputEmpty();
          } else {
            scheduleVerticalLayout();
          }
        });
      });

      zoomRange.addEventListener("input", (event) => {
        const value = parseFloat(event.target.value);
        zoomTo(value);
      });

      fitBtn.addEventListener("click", () => {
        if (!state.imageLoaded) return;
        fitImageToStage();
      });

      centerBtn.addEventListener("click", () => {
        if (!state.imageLoaded) return;
        centerImage();
      });

      rotateBtn.addEventListener("click", () => {
        rotateBy(90);
      });

      mirrorBtn.addEventListener("click", () => {
        state.mirror = !state.mirror;
        updateMirrorLabel();
        applyRotation();
      });

      cropBtn.addEventListener("click", () => {
        drawSlices();
      });

      stage.addEventListener("pointerdown", (event) => {
        if (!state.imageLoaded) return;
        state.dragging = true;
        state.dragStartX = event.clientX;
        state.dragStartY = event.clientY;
        state.dragOriginX = state.offsetX;
        state.dragOriginY = state.offsetY;
        stage.setPointerCapture(event.pointerId);
      });

      stage.addEventListener("pointermove", (event) => {
        if (!state.dragging) return;
        const dx = event.clientX - state.dragStartX;
        const dy = event.clientY - state.dragStartY;
        state.offsetX = state.dragOriginX + dx;
        state.offsetY = state.dragOriginY + dy;
        clampOffsets();
        applyTransform();
      });

      stage.addEventListener("pointerup", (event) => {
        state.dragging = false;
        stage.releasePointerCapture(event.pointerId);
      });

      stage.addEventListener("pointerleave", () => {
        state.dragging = false;
      });

      stage.addEventListener(
        "wheel",
        (event) => {
          if (!state.imageLoaded) return;
          event.preventDefault();
          const delta = -event.deltaY * 0.001;
          const nextScale = state.scale * (1 + delta);
          const rect = stage.getBoundingClientRect();
          const focusX = event.clientX - rect.left;
          const focusY = event.clientY - rect.top;
          zoomTo(nextScale, focusX, focusY);
        },
        { passive: false }
      );

      window.addEventListener("resize", () => {
        scheduleVerticalLayout(state.imageLoaded);
      });

      setStageRatio();
      renderTiles();
      updateOutputLayout();
      scheduleVerticalLayout();
      setOutputEmpty();
    </script>
  </body>
</html>
